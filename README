Componenti del gruppo:

    Nome         -           Cognome             -        Numero di matricola
 Federica        -           Belotti             -           193872
 Claudio         -           Facchinetti         -           193588
 Federica        -           Ress                -           195172

Breve descrizione del progetto:
Emulazione di un sistema di domotica. Il progetto è stato implementato con la variante dei processi. 

I dispositivi creano tre diversi processi che comunicano tra di loro sulla stessa pipe.
I processi sono:
- 1. il processo del dispositivo
- 2. il processo che si occupa di comunicare con le interazioni esterne.
- 3. il processo che si occupa di comunicare con il controllore.
Le pipe sono chiamate:
- pipe_interna: comunica tra i processi 1 e 2 e 2 e 3, ossia pipe destinata alle comunicazioni all'interno del dispositivo
- pipe_esterna: comunica tra i processi 2 e il processo rappresentante l'interazione esterna, ossia pipe destinata alle comunicazioni con l'umano
- pipe <id>: comunica tra i processi 3 e il controllore del dispositivo, ossia pipe destinata alle comunicazioni con il processo padre



[inserire qua gestione di blocking @Claudio ]
[Inserire qua la gestione delle pipe @Claudio]

Questo sistema di gestione è comune per tutti le tipologie di dispositivi emulate da questo progetto.

[altre cose in comune?]

Differenze tra dispositivi di controllo e di interazione

La differenza tra dispositivi di controllo e dispositivi di interazione è principalmente nella gestione di messaggi. 

La gestione dei messaggi in entrata propri (con id_destinatario == id_dispositivo) è simile per tutti i dispositivi.
Dopo un controllo sull'id c'è un controllo sul tipo di messaggio, su che interruttore questo agisce e come.
Ogni dispositivo può gestire messaggi di tipo diverso, i quali sono descritti in seguito in questo file per ogni dispositivo.

La gestione dei messaggi in entrata non propri (con id_destinatario != id_dispositivo) è descritta in seguito.
Quando un dispositivo di controllo riceve un messaggio non proprio chiede ai/al propri/o figli/o se può mandare il messaggio per arrivare al dispositivo interessato. 
Se un dispositivo di interazione riceve un messaggio non proprio, ignora il messaggio stesso.

[altre differenze?]

//???

// ? altro?
 
Note sui componenti
In seguito delle note sui vari tipi di dispositivi. In particolare sono descritti i tipi di messaggi che ogni dispositivo gestisce.

Dispositivi di controllo
Centralina:
Comunica ai figli attraverso messaggi nel seguente formato:
(1) "STATUSGET" per richiedere lo stato di un dispositivo
(2)"ID": chiede se può arrivare al dispositivo con id <ID> tramite un dispositivo
(3)"LABELUP": per modificare gli interruttori di un dispositivo
(4)"REMOVE": per rimuovere un dispositivo
(6)"STATUSGETRES": messaggio di risposta a messaggi di risposta a messaggi del tipo (1) dai dispositivi, i quali vengono poi interpretati per generare una stampa a video delle informazioni richieste ai dispositivi.



Hub:
Può interpretare i seguenti tipi di messaggi:
(1)
(2)
[...]
Può inviare alla centralina il seguente tipo di messaggio:
()
[...]

Timer:
Può interpretare i seguenti tipi di messaggi:
(1)
(2)
[...]
Può inviare alla centralina il seguente tipo di messaggio:
()
[...]

Dispositivi di interazione
Finestra:
Può interpretare i seguenti tipi di messaggi:
(1)
(2)
[...]
Può inviare alla centralina il seguente tipo di messaggio:
()
[...]

// INIZIO PARTE DA TOGLIERE
/*
---------------------------------------v0:---------------------------Questo secondo me è inutile (è ciò che fa detto il prof nel suo file, lo sa già)
Ha un registro che indica il tempo di utilizzo. Controlla l'input e sovrascrive i valori in input, se disponibili. Chiama una funzione a supporto che contiene la logica del programma. Questa funzione crea i processi a supporto e resta perennemente in ascolto sulla propria pipe. ...
...
...
//(manca ancora altre cose, quindi viene decisamente troppo lungo, secondo me)
*/
//Okay, dato che viene troppo lungo proviamo una descrizione più corta

/*---------------------------------------v1:------------------------------- Questo è da descrivere sopra (parte in comune), da togliere
La finestra gestisce i propri messaggi rispondendo con:
- un messaggio "FALSE" sulla pipe_interna se l'id non corrisponde
- //altri casi ??

- un messaggio "TRUE" sulla pipe_interna se l'id corrisponde. In questo caso, in base al messaggio ricevuto reagisce compiendo le  l'azione indicata dal messaggio. 
Le azioni eseguibili sono indicate nel makefile.
*/ 
// FINE PARTE DA TOGLIERE


Frigo:
Può interpretare i seguenti tipi di messaggi:
(1)
(2)
[...]
Può inviare alla centralina il seguente tipo di messaggio:
()
[...]
[...]

Implementazione di umano:
[...]

L'umano esegue sempre la stessa funzione la quale:
- chiede in input l'id dispositivo e il tipo di messaggio da mandare
- invia un hmessaggio all'id interessato
- interpreta i messaggi che arrivano 
Può interpretare i seguenti tipi di messaggi:
(1)
(2)

[...]

Può inviare alla centralina i seguenti tipi di messaggio:
()

[...]

//??? è così? Manca qualcosa? 


Makefile
Il makefile contiene le tre ricette indicate nella consegna ("help", "build" e "clean"), inoltre:
-
-
-


Varie ed eventuali:
[...]

Errori ed exit:
Il sistema risponde con un errore e una exit nei seguenti casi:

- exit (0): quando gli argomenti in linea di input sono minori di quelli accettati dal programma (meno di 2)
- exit (130): quando 
- exit ():
[...]



Override: 
E' uno stato che ha solo l'hub e il timer. Entrambi controllano se il/i figlio/i sia/siano in uno stato consistente oppure no.

[...]

// Forse manca qualcosa nel codice, per gestire l'override?

Shell:
Il sistema utilizza una sola shell per l'interazione con l'utente. I processi non generano altre shell e l'interazione può avvenire da terminale testuale.

Il progetto funziona sui seguenti ambienti testati: 
- Ubuntu 18.x (come richiesto)
- macOS Mojave ( 14.1.2 )
- macOS High Sierra ( 13.4.1 )
- 

[inserire ambienti testati oltre Ubuntu 18.x, se non ce ne sono cancellare questa parte xD, LoOOo0o0oL]


Comando "add" nella centralina:
Quando si esegue un comando "add" per un nuovo dispositivo (qualsiasi tipo), vi è la generazione di un processo figlio, il quale genera un altro processo figlio per poi terminare. In questo modo il processo del componente viene adottato da init() e quindi non risulta figlio della centralina.


/*
* nota:  [...] significa inserire commenti/note relative
*
*/

(eof)
-----------------------------------------------------------------------------------------------------------------------------------
Piccolo commento:
Secondo me è inutile scrivere in questo file tutti i registri/interruttori presenti, dal momento che è quello che il professore già sa, dato che richiesto da lui.
Secondo me vuole capire come abbiamo implementato le varie cose, tipo cosa è per noi un registro (nelle librerie) oppure le funzioni varie. 
E' utile aggiungere cosa fanno i vari messaggi perché il professore non ha specificato il formato dei messaggi, come ha scritto sulla mail per lui basta ci siano nomi significativi. 
E' importante spiegare come sia implementato l'override. (OK?)

----------------------------------------------------- [TODO]-----------------------------------------------------------------------

DA AGGIUNGERE:
- tipi di messaggi 																	--> TODO (in lavorazione)
- override																			--> OK (sistemato)
- gestione delle pipe (blocking)													--> TODO (Claudio) (a quanto pare da non scrivere)
- cose in comune tra i Dispositivi  												--> altro?
- differenze tra Dispositivi 														--> altro?
- messaggi in secondi per alarm   													--> TODO (da mettere nel messaggio delay del frigo!)
- shell: gestione (una sola shell e perché) 										--> altro?
- tipi di errori/exit 																--> in lavorazione //TODO MAKEFILE
- ricette "in più" nel makefile (oltre a help, clean e build)						--> TODO
- versioni di Ubuntu testate oltre la 18.x (se abbiamo testato altro)				--> TODO (aggiunto macOS)
- cancellare commenti inutili in questo file quando è completo						
- controllare la sintassi e la grammatica di questo file
- rileggere tutto quanto un paio di volte per sincerarsi della correttezza di ciò che ho scritto qua dentro
- la storia dei tre processini e delle tre pipe(ine)								--> OK 
- add: processo creato																--> OK
-
-



----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------